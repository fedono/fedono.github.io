---
layout: post 
title: "Node 垃圾回收" 
author: "fedono"
---

在朴灵的那本《深入浅出Node.js》 中第五章中讲的是V8 的垃圾回收机制，可是浏览器的JS引擎不也是V8吗，为什么在说浏览器的垃圾回收的时候，都是标记清除和引用计数呢。

> 哦深入浅出这本书中说的是 V8 的内存分代是将内存分为新生代和老生代，然后不太分代的内存使用了不同的算法，而不是说使用了什么样的回收机制？我可以这样理解吗？

## 回收算法

现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别的不同分代的内存施以更高效的算法。

1. 新生代中的对象主要使用了 Scavenge 算法，具体实现中主要采用了 Cheney 算法

   算法内容：将堆内存分为两部分，一部分成为From，另一部分成为To，To是闲置的，先在From中进行对象分配，内存回收时，将Form中的存活对象复制到To空间中，非存活的就直接释放。

   算法缺点：只能使用堆内存中的一半，典型的牺牲空间换取时间

2. 老生代中的对象由于存活对象占较大比重，采用Scavenge算法效率低，所以采用 Mark-Sweep 和 Mark-Compact 相结合的方式

   算法内容：Mark-Sweep 是标记清除，遍历堆中的所有对象，标记或者的对象，在清除阶段，清除没有标记的对象。

   算法缺点：标记清除回收后，内存空间不连续，所以需要Mark-Compact 来标记整理，将或者的对象往一端移动，移动完成后，清理掉边界外的内存。
   
3. 新生代算法和老生代算法对比：

   新生代算法只处理活着的对象，老生代算法只处理死亡的对象。

4. 优化

   以上的三种算法在执行的时候，都需要将应用逻辑暂停，新生代的配置小，暂停影响不大，就剩带配置比较大，暂停就影响较大

   V8 从标记阶段入手，将原本需要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分成多个步骤来完成，没完成异步，就让应用执行一会。也就是垃圾回收与应用执行交替执行。

## 内存泄漏排查

Node 中需要排查内存泄漏，还是得靠工具才行，不想浏览器中可以有控制台来进行查看。

- 使用 node-heapdump ，允许对V8 堆内存抓取快照，用于事后分析
- node-mtrace，使用了 GCC 的 mtrace 工具来分析堆的使用
- node-memwatch 等

